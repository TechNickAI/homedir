# This file contains code that is specific to OSX

# Python and javascript seem to want these
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Homebrew path setup
export HOMEBREW_BREWFILE=~/homedir/Brewfile
if [ -f /opt/homebrew/bin/brew ]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
fi

# Create aliases for virtualenvs that have matching ~/src directories
# Inverted loop: iterate virtualenvs (fewer) instead of src dirs (many)
for venv in ~/.virtualenvs/*/; do
    [[ -d "$venv" ]] || continue
    env_name=$(basename "$venv")
    if [[ -d ~/src/$env_name ]]; then
        alias $env_name="cd ~/src/$env_name; source $venv/bin/activate"
    fi
done

#### Aliases
alias ip='dig +short myip.opendns.com @resolver1.opendns.com'
alias localip="ipconfig getifaddr en0"
alias randpick='jot -r 1 1'
alias agp="ag -G '.py'"
alias family_guy="find ~/Dropbox/Watch/Family\ Guy/ -type f -print0 | sort -zR | head -n 1 | xargs -0 vlc -f --play-and-exit"
alias office="find ~/Dropbox/Watch/The\ Office/ -type f -print0 | sort -zR | head -n 1 | xargs -0 vlc -f --play-and-exit"

#### Functions
function commit_link() {
    ## Grab the latest commit from the current repo and copy the link to the clipboard.

    # hash
    hash=$(git log -n 1 --format="%H")
    if [ $? != 0 ]; then
        echo "Oops! Not a Git repository ğŸš«"
        return
    fi

    # repo owner/name (clean extraction)
    remote_url=$(git remote get-url origin)
    repo=$(echo "$remote_url" | sed -E 's#(git@github.com:|https://github.com/)([^/]+/[^.]+)(.git)?#\2#')
    url="https://github.com/$repo/commit/$hash"
    echo $url
    echo "Copied to clipboard... ğŸ“‹"
    echo $url | pbcopy
}

function wifi_redirect() {
    # Solves the "stuck on Wi-Fi login page" problem
    #
    # When connecting to public Wi-Fi networks (e.g., in cafes, hotels, airports),
    # you often need to agree to terms or log in, but the login page doesn't always
    # appear automatically. This function detects such situations and opens the
    # login page for you, saving time and frustration.

    local check_interval=2
    local test_url
    if [[ -n "$1" ]]; then
        test_url="$1"
    else
        test_url="http://example.com"
    fi

    while true; do
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "$test_url")
        if [[ $status_code == "000" ]]; then
            echo "ğŸŒ Internet connection is down. Retrying in $check_interval seconds... â³"
            sleep $check_interval
            let check_interval=$check_interval+1
        elif [[ $status_code -ge 300 && $status_code -lt 400 ]]; then
            redirect_url=$(curl -s -I "$test_url" | grep -i "Location" | awk -F' ' '{print $2}' | tr -d '\r')
            echo "ğŸ”„ Detected a redirect, opening $redirect_url ğŸŒ"
            open "$redirect_url"
            break
        elif [[ $status_code -eq 200 ]]; then
            echo "âœ… Internet is working. Opening https://ismyinternetworking.com ğŸŒ"
            open "https://ismyinternetworking.com"
            break
        else
            echo "â“ Unexpected response from curl: $status_code. Exiting..."
            return
        fi
    done
}

### Handle env files

# Function to source an env file and export variables
function load_env_file() {
    local env_file=$1

    if [[ ! -f $env_file ]]; then
        echo "File not found: $env_file"
        return 1
    fi

    # Source the file
    source "$env_file"

    # Export each variable
    while IFS='=' read -r key value; do
        # Skip blank lines and comments
        [[ -z "$key" || "$key" =~ ^# ]] && continue

        # Remove surrounding quotes from the value if present
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//')

        # Export the key-value pair
        export "$key=$value"
    done <"$env_file"
}

# List of env file locations (files or directories)
env_locations=(
    "$HOME/dot_env_shared"
    "$HOME/dot_env_local"
    "$HOME/env"
    "$HOME/src/env"
    "$HOME/.env"
)

# Loop through each location
for location in "${env_locations[@]}"; do
    if [[ -d $location ]]; then
        # If it's a directory, read all files in the directory
        for env_file in "$location"/*; do
            if [[ -f $env_file ]]; then
                load_env_file "$env_file"
            fi
        done
    elif [[ -f $location ]]; then
        # If it's a file, read the file
        load_env_file "$location"
    fi

done

# New function to show environment variables loaded from each env file
function show_env_vars() {
    for location in "${env_locations[@]}"; do
        if [[ -d $location ]]; then
            for env_file in "$location"/*; do
                if [[ -f $env_file ]]; then
                    echo "\nVariables from $env_file:"
                    grep -v '^#' "$env_file" | while IFS='=' read -r key value; do
                        [[ -z "$key" ]] && continue
                        echo "$key=$(printenv $key)"
                    done
                fi
            done
        elif [[ -f $location ]]; then
            echo "\nVariables from $location:"
            grep -v '^#' "$location" | while IFS='=' read -r key value; do
                [[ -z "$key" ]] && continue
                echo "$key=$(printenv $key)"
            done
        fi
    done
}
# Add an alias for show_env_vars as browse_env_vars
alias browse_env_vars='show_env_vars'

#### Project Clone Functions

# Smart git update: handles merged branches, uncommitted/unpushed changes
_smart_git_update() {
  local current_branch=$(git branch --show-current)

  # Check for uncommitted changes
  if [[ -n $(git status --porcelain) ]]; then
    echo "âš ï¸  Uncommitted changes detected, staying on $current_branch"
    return 0
  fi

  # If on main, just pull
  if [[ "$current_branch" == "main" ]]; then
    git pull
    return 0
  fi

  # Fetch latest from origin
  git fetch origin main

  # Check for unpushed commits
  local unpushed=$(git rev-list --count origin/$current_branch..$current_branch 2>/dev/null)
  if [[ -n "$unpushed" && "$unpushed" -gt 0 ]]; then
    echo "âš ï¸  Branch $current_branch has $unpushed unpushed commit(s), staying put"
    git pull
    return 0
  fi

  # Check if branch is merged into main
  if git branch --merged origin/main | grep -q "^[* ] $current_branch$"; then
    echo "âœ… Branch $current_branch merged into main, switching..."
    git checkout main && git pull
  else
    echo "ğŸ”„ Updating $current_branch..."
    git pull
  fi
}

# Clone carmenta with environment setup
clone-carmenta() {
  local new_name=$1
  local source_dir="$HOME/src/carmenta"
  local target_dir="$HOME/src/carmenta-$new_name"

  if [[ -d "$target_dir" ]]; then
    echo "ğŸ“ Directory exists, updating $new_name..."
    cd "$target_dir" || return 1
    _smart_git_update
  else
    echo "ğŸ”„ Cloning carmenta to $new_name..."
    git clone git@github.com:carmentacollective/carmenta.git "$target_dir" || return 1
    cd "$target_dir" || return 1
  fi

  if [[ -f "$source_dir/.env.local" ]]; then
    echo "ğŸ“‹ Copying .env.local..."
    cp "$source_dir/.env.local" .
  fi

  if [[ -d "$source_dir/.vercel" ]]; then
    echo "ğŸ“‹ Syncing .vercel..."
    rsync -a "$source_dir/.vercel/" .vercel/
  fi

  echo "ğŸ“¦ Installing dependencies..."
  pnpm i

  echo "âœ¨ Ready to work in $target_dir"
}

# Clone cryptoai (Python project)
clone-cryptoai() {
  local new_name=$1
  local target_dir="$HOME/src/cryptoai-$new_name"

  if [[ -d "$target_dir" ]]; then
    echo "ğŸ“ Directory exists, updating $new_name..."
    cd "$target_dir" || return 1
    _smart_git_update
  else
    echo "ğŸ”„ Cloning cryptoai to $new_name..."
    git clone git@github.com:carmentacollective/cryptoai.git "$target_dir" || return 1
    cd "$target_dir" || return 1
  fi

  echo "âœ¨ Ready to work in $target_dir"
}
